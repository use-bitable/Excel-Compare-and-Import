import{i as o,g as A,U as P,I as ae,L as ce,h as q,G as re,j,k as ue,l as H,n as ee,r as le,s as K,t as W,v as ge,w as C,S as me,x as fe}from"./index-D26RMV9H.js";var z=(t=>(t.Update="update",t.Delete="delete",t.Add="add",t.Link="link",t.Async="async",t))(z||{});async function pe(t,a){const r=await t.getName();return async s=>{try{const e=await t.addRecords(s.map(n=>n.data));s.forEach((n,d)=>{e[d]&&(n.result=e[d],n.status=j.Success)}),a(o.onAddRecords,{stage:"addRecords",data:{success:s,message:{text:"importInfo.addRecordsMessage",params:{table:r}}}})}catch(e){W({title:"addRecordsFailure",message:String(e),error:e}),s.forEach(n=>{n.status=j.Error}),a(o.onAddRecords,{stage:"addRecords",data:{error:s}})}}}async function ye(t,a){const r=await t.getName();return async s=>{try{const e=await t.setRecords(s.map(n=>n.data).flat());s.forEach((n,d)=>{e[d]&&(n.result=e[d],n.status=j.Success)}),a(o.onUpdateRecords,{stage:"updateRecords",data:{success:s,message:{text:"importInfo.updateRecordsMessage",params:{table:r}}}})}catch(e){W({title:"updateRecordsFailure",message:String(e),error:e}),s.forEach(n=>{n.status=j.Error}),a(o.onUpdateRecords,{stage:"updateRecords",data:{error:s}})}}}async function be(t,a){const r=await t.getName();return async s=>{try{const e=await t.deleteRecords(s.map(n=>n.data).flat());e&&s.forEach(n=>{n.result=e,n.status=j.Success}),a(o.onDeleteRecords,{stage:"deleteRecords",data:{success:s,message:{text:"importInfo.deleteRecordsMessage",params:{table:r}}}})}catch(e){W({title:"deleteRecordsFailure",message:String(e),error:e}),s.forEach(n=>{n.status=j.Error}),a(o.onDeleteRecords,{stage:"deleteRecords",data:{error:s}})}}}async function he(t,a,r=500,s=500,e){await C(r,s,t,await pe(a,e))}async function Re(t,a,r=500,s=500,e){return await C(r,s,t,await ye(a,e))}async function we(t,a,r=500,s=500,e){return await C(r,s,t,await be(a,e))}async function Ie(t,a,r,s,e){return t===a?null:r===q.merge_direct||a===null?await A.getCell(s,e,t):await A.getCell(s,e,a)}async function se(t,a,r=!1,s,e){try{const n=await fe.base.getTable(t),[d,m,R]=await Promise.all([n.getName(),n.getFieldList(),n.getFieldMetaList()]);s(o.onReadFieldMap,{stage:"readFieldMap",data:{message:{text:"importInfo.getTable",params:{name:d,id:t}}}});const f=R.filter(c=>c.isPrimary)[0].id;return{id:t,table:n,name:d,primaryField:f,indexId:e!=null&&e.length?e:[f],root:r,fields:m.reduce((c,u)=>(c[u.id]=u,c),{}),fieldMaps:a}}catch(n){throw W({title:"getTableFailure",message:String(n),error:n,notice:!0,noticeParams:{text:"message.getTableFailure",params:{id:t}}}),n}}async function ne(t,a,r=1e4,s=0){const e=[];return await C(r,s,t,async n=>{await Promise.allSettled(n.map(async d=>{const m=await a(d);Array.isArray(m)?e.push(...m):e.push(m)}))}),e}async function oe(t,a,r,s,e,n,d,m){if(!A.asyncTypes.includes(a.field.type))return null;const R=await A.normalization(t,a);if(!R)return null;const f=[R],V={table:{name:s[a.table].name,id:a.table},action:z.Async,data:f,result:void 0,status:j.Wait,target:m,asyncField:a,value:t,field:r};n.push(V)}async function ie(t,a,r,s,e,n,d,m){var L;if(!((L=a.children)!=null&&L.length))return null;const{linkConfig:R}=a,{allowAdd:f,primaryKey:V}=R??{};if(!V||f===void 0)return null;const c=await A.normalization(t,a),u=s[a.field.property.tableId],U=e[u.id],O=[];d(o.onAnalyzeRecords,{stage:"analyzeRecords",data:{message:{text:"importInfo.getLinkRecord",params:{indexValue:c.join("|"),fieldName:a.field.name,fieldId:r.id,table:u.name}}}});const J=c.map(v=>{const $=U.filter(_=>_.indexValue[0]===v);return $.length===0?(O.push(v),null):$.map(_=>_.recordId)}).flat().filter(v=>v!==null);if((!O.length||!f)&&J.length){const v=await A.getCell(r,a,J.join(a.config.separator??","));return v||null}}async function de(t,a,r,s,e,n,d){var u;if(!a.excel_field||!a.writable)return null;const m=t[a.excel_field]??null;if(!m)return null;const R=r[a.table].fields[a.field.id],f=le.includes(a.field.type),{linkConfig:V}=a,{primaryKey:c}=V??{};if(f&&a.hasChildren&&((u=a.children)!=null&&u.length)&&c)return await ie(m,a,R,r,s,e,n);if(A.asyncTypes.includes(a.field.type)&&await oe(m,a,R,r,s,e,n,d),!f){const U=await A.getCell(R,a,m);if(U)return U}return null}async function Fe(t,a){try{let r=!1;if(!a){const e=await t.addField({type:re.ModifiedTime});a=await t.getField(e),r=!0}const s=await a.getFieldValueList();return r&&t.deleteField(a),s.reduce((e,n)=>(n.record_id&&(e[n.record_id]=n.value),e),{})}catch(r){return W({title:"getModifiedTimeFailure",message:String(r),error:r,notice:!0,noticeParams:{text:"message.getModifiedTimeFailure",params:{id:t.id}}}),{}}}async function Te(t,a,r){return await Promise.all(a.map(async e=>{r(o.onReadFieldMap,{stage:"readFieldMap",data:{message:{text:"importInfo.getFieldCellString",params:{field:t.id,record:e}}}});const n=await t.getCellString(e);return{recordId:e,value:n}}))}async function xe(t,a,r){let s={};const e=t[0].table;s[e]=await se(e,t,t[0].root,r,a);for(const n of t)if(n.excel_field&&n.hasChildren&&n.linkConfig&&!Object.keys(s).includes(n.field.property.tableId)){const d=n.field.property.tableId;s[d]=await se(d,n.children??[],!1,r,n.linkConfig.primaryKey?[n.linkConfig.primaryKey]:void 0)}return s}async function Se(t,a,r){const s=await t.getRecordIdList();return await Promise.all(a.map(async n=>{const d=await t.getField(n.field.id);return r(o.onReadFieldMap,{stage:"readFieldMap",data:{message:{text:"importInfo.getIndexField",params:{name:n.field.name,id:n.field.id}}}}),{values:await Te(d,s,r),fieldMap:n}})).then(async n=>Promise.all(s.map(async d=>{var R;const m=[];for(const f of n){const V=((R=f.values.find(u=>u.recordId===d))==null?void 0:R.value)??"";r(o.onReadFieldMap,{stage:"readFieldMap",data:{message:{text:"importInfo.analyzeIndexFieldValue",params:{fieldName:f.fieldMap.field.name,fieldId:f.fieldMap.field.id,recordId:d}}}});const c=await A.normalization(V,f.fieldMap,{separator:",",format:["yyyy/MM/dd","yyyy/MM/dd HH:mm","yyyy-MM-dd HH:mm","yyyy-MM-dd","MM-dd","MM/dd/yyyy","dd/MM/yyyy"]});m.push(c)}return{indexValue:m,table:t.id,recordId:d,fieldMaps:a}})).catch(d=>{throw W({title:"getTableIndexFailure",message:String(d),error:d,notice:!0,noticeParams:{text:"message.getTableIndexFailure",params:{id:t.id}}}),d}))}async function Ae(t){const a=[];let r;for(;;){const s=await t.getRecords({pageSize:5e3,pageToken:r});if(r=s.pageToken,a.push(...s.records),!s.hasMore||!r)break}return a.reduce((s,e)=>(s[e.recordId]=e.fields,s),{})}async function Ve(t,a,r,s){for(const e of t){if(!me.includes(e.field.type))continue;const n=e.excel_field;if(!n)continue;s(o.onReadFieldMap,{stage:"readFieldMap",data:{message:{text:"importInfo.checkSelectFieldOptions",params:{fieldName:e.field.name,fieldId:e.field.id}}}});const d=r.map(c=>c[n]).filter(ee),m=a[e.field.id],R=(await m.getOptions()).map(c=>c.name),V=H((await Promise.all(d.map(async c=>await A.normalization(c,e)))).filter(ee).flat()).filter(c=>!R.includes(c));V.length&&(s(o.onReadFieldMap,{stage:"readFieldMap",data:{message:{text:"importInfo.setSelectFieldOptions",params:{fieldName:e.field.name,fieldId:e.field.id,newOptionsNum:String(V.length)}}}}),await m.addOptions(V.map(c=>({name:c}))))}}async function Me(t,a,r,s=null,e=q.append,n={},d=ge){var te;console.log(t),d(o.onStart,{stage:"start"}),A.refresh(),d(o.beforeReadFieldMap,{stage:"readFieldMap",data:{progress:!1}});const{parallel:m={records:1e4,fields:10},interval:R={records:0,fields:0},allowAction:f={add:!0,update:!0,delete:!0},updateOption:V={mode:[P.SAVE_MOST,P.SAVE_LATEST]}}=n;ae({title:"importInfo.start",message:`
    Mode: ${e}
    SheetIndex: ${r}
    index: ${s}
    parallel:
      - fields: ${m.fields}
      - records: ${m.records}
    interval:
      - fields: ${R.fields}
      - records: ${R.records}
    allowAction:
      - add: ${f.add}
      - update: ${f.update}
      - delete: ${f.delete}
    updateOption:
      - mode: ${V.mode}
    `});const c=a.sheets[r].tableData.records,u=await xe(t,s??[],d);ce({title:"tables",message:JSON.stringify(u,null,2)});const U=[],O=u[t[0].table].table;let J={};if(e!==q.append){d(o.onReadFieldMap,{stage:"readFieldMap",data:{message:{text:"importInfo.getRecordsModifiedTime"}}});const p=(te=t.find(b=>b.field.type===re.ModifiedTime))==null?void 0:te.field.id,S=p?await O.getField(p):void 0;J=await Fe(O,S)}await Ve(t,u[t[0].table].fields,c,d);const L={};await Promise.all(Object.values(u).map(async p=>{const S=p.indexId,b=await Se(p.table,S.map(w=>p.fieldMaps.find(g=>g.field.id===w)),d);L[p.id]=b.map(w=>({...w,modifiedTime:J[w.recordId]??0}))})),s&&s.length&&U.push(...L[O.id]),d(o.onReadFieldMapEnd,{stage:"readFieldMap"});const v=[];if(d(o.beforeAnalyzeRecords,{stage:"analyzeRecords",data:{progress:!0,number:c.length,success:0,error:0}}),e===q.append||!s){const p=await ne(c,async S=>{const b=[],w={table:{id:t[0].table,name:u[t[0].table].name},action:z.Add,data:[],result:void 0,status:j.Wait},g=[];for(const I of t){const F=await de(S,I,u,L,b,d,w);F&&g.push(F)}return d(o.onAnalyzeRecords,{stage:"analyzeRecords",data:{number:c.length,success:1,error:0}}),g.length&&(w.data.push(...g),b.push(w)),b},m.records,R.records);v.push(...p)}else{const p=s.map(g=>{const I=t.find(F=>F.field.id===g);return I||null});ae({title:"excelIndexField",message:JSON.stringify(p,null,2)}),d(o.onAnalyzeRecords,{stage:"analyzeRecords",data:{message:{text:"importInfo.getTableRecords",params:{table:O.id}}}});const S=await Ae(O),b=[],w=await ne(c,async g=>{var k;const I=[],F=await Promise.all(p.map(async l=>await A.normalization(g[l.excel_field]??"",l))),N=U.filter(l=>ue(l.indexValue,F));d(o.onAnalyzeRecords,{stage:"analyzeRecords",data:{message:{text:"importInfo.findSameRecord",params:{indexValue:F.join("|"),number:String(N.length)}}}});const M=[];let E=null;if(N.length>=1){for(const l of N){d(o.onAnalyzeRecords,{stage:"analyzeRecords",data:{message:{text:"importInfo.getSameRecord",params:{indexValue:F.join("|"),recordId:l.recordId}}}});const T=S[l.recordId],h={...l,tableValues:Object.keys(T).reduce((y,i)=>(T[i]!==null&&(y[i]=T[i]),y),{})};M.push(h)}if(M.length>1){const{mode:l}=V;if([P.SAVE_LATEST,P.SAVE_OLDEST].includes(l[0])){const T=H(M.map(i=>i.modifiedTime)),h=l[0]===P.SAVE_LATEST?Math.max(...T):Math.min(...T),y=M.filter(i=>i.modifiedTime===h);if(y.length===1){const i=y[0];E={id:i.recordId,table:i.table,tableValues:i.tableValues}}else{y.sort((X,B)=>Object.values(X.tableValues).length-Object.values(B.tableValues).length);const i=l[1]===P.SAVE_MOST?y[y.length-1]:y[0];E={id:i.recordId,table:i.table,tableValues:i.tableValues}}}else{const T=H(M.map(i=>Object.values(i.tableValues).length)),h=l[0]===P.SAVE_MOST?Math.max(...T):Math.min(...T),y=M.filter(i=>Object.values(i.tableValues).length===h);if(y.length===1){const i=y[0];E={id:i.recordId,table:i.table,tableValues:i.tableValues}}else{y.sort((X,B)=>X.modifiedTime-B.modifiedTime);const i=l[1]===P.SAVE_LATEST?y[y.length-1]:y[0];E={id:i.recordId,table:i.table,tableValues:i.tableValues}}}if(ee(E)){const T=M.map(h=>h.recordId).filter(h=>h!==E.id).filter(h=>!b.includes(h));b.push(...T),I.push(...T.map(h=>({table:{id:O.id,name:u[O.id].name},action:z.Delete,data:[h],result:void 0,status:j.Wait})))}}else{const l=M[0];E={id:l.recordId,table:l.table,tableValues:l.tableValues}}}const x={table:{id:O.id,name:u[O.id].name},action:z.Add,data:[],result:void 0,status:j.Wait},D=[];for(const l of t){if(!l.excel_field||!l.writable)continue;const T=g[l.excel_field]??"",h=u[l.table].fields[l.field.id];if(d(o.onAnalyzeRecords,{stage:"analyzeRecords",data:{message:{text:"importInfo.compareRecordField",params:{fieldName:l.field.name,fieldId:h.id,indexValue:F.join("|")}}}}),f.add&&!N.length){const G=await de(g,l,u,L,I,d,x);D.push(G)}if(!f.update||!E)continue;const y=le.includes(l.field.type),{linkConfig:i}=l,{primaryKey:X}=i??{},B=E.tableValues[l.field.id]??null;if(y&&l.hasChildren&&((k=l.children)!=null&&k.length)&&X&&(e===q.merge_direct||B===null)){const G=await ie(T,l,h,u,L,v,d);D.push(G)}if(A.asyncTypes.includes(l.field.type)&&await oe(T,l,h,u,L,v,d,x),!y){const G=await Ie(T,B,e,h,l);G&&D.push(G)}}if(d(o.onAnalyzeRecords,{stage:"analyzeRecords",data:{number:c.length,success:1,error:0}}),M.length){x.action=z.Update;const l={};for(const h of D.filter(y=>y!==null)){const[y,i]=await Promise.all([h.getFieldId(),h.getValue()]);l[y]=i}const T={recordId:E.id,fields:l};return x.data.push(T),I.push(x),I}return x.data.push(...D.filter(l=>l!==null)),I.push(x),I},m.records,R.records);v.push(...w)}d(o.onAnalyzeRecordsEnd,{stage:"analyzeRecords"});const $=K(v,"action"),_=$[z.Async];if(_&&_.length){const p=K(_,"asyncField.field.type"),S=Object.keys(p),b=S.reduce((g,I)=>(g[I]=p[I].map(F=>F.data).flat(),g),{});d(o.beforeAsyncData,{stage:"asyncData",data:{progress:!0,number:_.length,success:[],error:[]}});for(const g of S){const I=p[g];await A.asyncMethod({data:b[g],onProgress:F=>{const{message:N="",loaded:M,total:E}=F;d(o.onAsyncData,{stage:"asyncData",data:{message:{text:N+`
${M}/${E}`}}})},onError:F=>{W({title:"asyncDataFailure",message:String(F),error:F})}},I[0].asyncField)}const w=K(_,"table.id");for(const g of Object.keys(w)){const I=u[g],F=w[g],N=K(F,"asyncField.field.id");for(const M of Object.keys(N)){const E=I.fields[M];for(const x of N[M]){d(o.onAsyncData,{stage:"asyncData",data:{message:{text:"importInfo.createCell",params:{fieldId:E.id,tableId:g}}}});const D=await A.getCell(E,x.asyncField,x.value);if(console.log(D,x.target),!(!D||!x.target)){if(x.target.action===z.Add)x.target.data.push(D);else if(x.target.action===z.Update){const[k,l]=await Promise.all([D.getFieldId(),D.getValue()]);x.target.data[0].fields[k]=l}x.status=j.Success}}}}d(o.onAsyncDataEnd,{stage:"asyncData"})}const Y=$[z.Delete];if(Y&&f.delete&&Y.length){d(o.beforeDeleteRecords,{stage:"deleteRecords",data:{progress:!0,number:Y.length,success:[],error:[]}});const p=K(Y,"table.id"),S=Object.keys(p);for(const b of S){const w=u[b],g=p[b];await we(g,w.table,5e3,0,d)}d(o.onDeleteRecordsEnd,{stage:"deleteRecords"})}const Q=$[z.Add];if(Q&&(e===q.append||f.add)&&Q&&Q.length){d(o.beforeAddRecords,{stage:"addRecords",data:{progress:!0,number:Q.length,success:[],error:[]}});const p=K(Q,"table.id"),S=Object.keys(p);for(const b of S){const w=u[b],g=p[b];await he(g,w.table,5e3,0,d)}d(o.onAddRecordsEnd,{stage:"addRecords"})}const Z=$[z.Update];if(Z&&f.update&&Z.length){d(o.beforeUpdateRecords,{stage:"updateRecords",data:{progress:!0,number:Z.length,success:[],error:[]}});const p=K(Z,"table.id"),S=Object.keys(p);for(const b of S){const w=u[b],g=p[b];await Re(g,w.table,5e3,0,d)}d(o.onUpdateRecordsEnd,{stage:"updateRecords"})}A.reset(),d(o.onEnd,{stage:"end"})}export{Me as importExcel};
